A string is mutable. In addition to = and += , subscripting (using [] ) and substring operations are
supported. The standard-library string is described in Chapter 36. Among other useful features, it
provides the ability to manipulate substrings. For example:

36.2.1 Classification Functions
In <cctype> , the standard library provides functions to classify the characters from the basic execu-
tion character set:

isspace(c)
Is c whitespace (space ' ' , horizontal tab '\t' , newline '\n' , vertical tab '\v' ,
form feed '\f' , carriage return '\r' )?

isalpha(c) // Is c a letter ( 'a' .. 'z' , 'A' .. 'Z' )? note: not underscore '_'
isdigit(c) // Is c a decimal digit ( '0' .. '9' )?

isupper(c) Is c an uppercase letter?
islower(c) Is c a lowercase letter?
isalnum(c) isalpha(c) or isdigit(c)
ispunct(c) Is c not a letter, digit, whitespace, or invisible control character?
isgraph(c) isalpha(c) or isdigit(c) or ispunct(c) ? note: not space

toupper(c) c or c ’s uppercase equivalent
tolower(c) c or c ’s lowercase equivalent

p2=find(p,n,c) // p points to the first occurrence of c in [ p : p+n ) or nullptr

s.reserve(n) // Ensure that s can hold n characters without further allocation.
n=s.capacity() // s can hold n characters without further allocation
s.clear() // Make s empty
s.empty() // Is s empty?
s.shrink_to_fit() // Make s.capacity==s.size()

An example:
void fill(istream& in, string& s, int max)
// use s as target for low-level input (simplified)
{
    s.reserve(max);
    // make sure there is enough allocated space
    in.read(&s[0],max);
    const int n = in.gcount();
    // number of characters read
    s.resize(n);
    s.shrink_to_fit();
    // discard excess capacity
}




s[i] // Subscripting: s[i] is a reference to the i th element of s ; no range check
s.at(i) // Subscripting: s.at(i) is a reference to the i th element of s ; throw range_error if s.size()<=i
s.front() // s[0]
s.back() // s[s.size()−1]

s.push_back(c) // Append the character c
s.pop_back() // Remove the last character from s : s.erase(s.size()−1)
s+=x // Append x at the end of s ; x can be a character, a string , a C-style string, or an initializer_list<char_type>
s=s1+s2 // Concatenation: optimized version of s=s1; s+=s2;

n2=s.copy(s2,n,pos) // s gets the characters from s2[pos:n2)
                        where n2 is min(n,s.size()−pos) ;
                        throw out_of_range if s.size()<pos
n2=s.copy(s2,n) // s gets all the characters from s2 ; n=s.copy(s2,n,0)

s.swap(s2) // Exchange the values of s and s2 ; noexcept
swap(s,s2) // s.swap(s2)
